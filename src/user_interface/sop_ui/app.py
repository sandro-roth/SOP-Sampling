import os

from dotenv import load_dotenv, find_dotenv
from pathlib import Path
from flask import Flask, render_template, request, redirect, url_for
from markupsafe import escape

from utils import setup_logging, get_logger
# from utils import conn_db, pull_db, push_db

# Setup
cwd = Path(__file__).resolve()

def _load_env() -> str | None:
    """
    Load environment variables from a suitable .env file.

    The function searches for a .env file in several prioritized locations:
    1. A path explicitly defined in the environment variable `SOP_UI_DOTENV_PATH`.
    2. A `.env` file located three directories above the current working file
       (used when running directly from an IDE or development environment).
    3. A `.env` file found automatically in the current working directory.

    Once found, the .env file is loaded using `python-dotenv`.

    Returns:
        str | None: The path to the loaded .env file, or None if no .env file was found.
    """
    explicit = os.getenv('SOP_UI_DOTENV_PATH')
    if explicit and Path(explicit).exists():
        load_dotenv(explicit)
        return explicit

    candidate = cwd.parents[3] / '.env' if len(cwd.parents) >= 4 else None
    if candidate and candidate.exists():
        load_dotenv(candidate)
        return str(candidate)

    found = find_dotenv(usecwd=True)
    if found:
        load_dotenv(found)
        return found

    return None

loaded_from = _load_env()

def get_next_example_from_db() -> tuple[int, str, str, str]:
    """
    This function retrieves next question (make sure every question only 2 annotators use predefined function)

    Returns:
         (question_id, question_text, answer_text, passage_text)
    """
    question_id = 1
    question_text = 'Example question from the database'
    answer_text = 'Example answer generated by the model'
    passage_text = ( 'This is an example passage.\n\n'
                     'Later this text will come from Postgres.')
    return question_id, question_text, answer_text, passage_text



def create_app() -> Flask:
    """
    Create and configure the Flask application.

    This function initializes a Flask app instance, sets up basic configuration,
    and defines routes for displaying and adding items to a list.

    Routes:
        GET /    – Render the main page showing the current list of items.
        POST /add – Add a new item to the list and update the page dynamically
                    if requested via HTMX.

    Returns:
        Flask: The configured Flask application instance.
    """
    app = Flask(__name__, template_folder=str(cwd.parent / 'templates'))
    app.config['TEMPLATES_AUTO_RELOAD'] = True
    items = []

    @app.get('/')
    def home():
        return render_template('index.html', items=items)

    @app.post('/add')
    def add():
        text = request.form.get("text", "").strip()
        if text:
            items.append(escape(text))
        if request.headers.get("HX-Request"):
            return render_template("_list.html", items=items)
        return redirect(url_for('home'))

    return app

def main() -> None:
    """
    Entry point for running the Flask application.

    This function creates the Flask app instance, reads the desired port
    from the environment variable `SOP_UI_PORT` (defaulting to 8000),
    and starts the development server.

    It also prints information about the loaded .env file and the chosen port
    for easier debugging and transparency during startup.

    Returns:
        None
    """
    setup_logging(app_name='user_interface', log_dir=os.getenv('GUI_LOG_DIR'))
    log = get_logger(__name__)

    app = create_app()
    port = int(os.getenv("SOP_UI_PORT", "8000"))
    log.info(f".env loaded from: {loaded_from}")
    log.info(f"SOP_UI_PORT = {port}")
    app.run(host='0.0.0.0', port=port, debug=False)


if __name__ == '__main__':
    main()