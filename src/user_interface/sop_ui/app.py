import os

from dotenv import load_dotenv, find_dotenv
from pathlib import Path
from flask import Flask, render_template, request, redirect, url_for

from utils import setup_logging, get_logger
# from utils import conn_db, pull_db, push_db

# Setup
cwd = Path(__file__).resolve()

def _load_env() -> str | None:
    """
    Load environment variables from a suitable .env file.

    The function searches for a .env file in several prioritized locations:
    1. A path explicitly defined in the environment variable `SOP_UI_DOTENV_PATH`.
    2. A `.env` file located three directories above the current working file
       (used when running directly from an IDE or development environment).
    3. A `.env` file found automatically in the current working directory.

    Once found, the .env file is loaded using `python-dotenv`.

    Returns:
        str | None: The path to the loaded .env file, or None if no .env file was found.
    """
    explicit = os.getenv('SOP_UI_DOTENV_PATH')
    if explicit and Path(explicit).exists():
        load_dotenv(explicit)
        return explicit

    candidate = cwd.parents[3] / '.env' if len(cwd.parents) >= 4 else None
    if candidate and candidate.exists():
        load_dotenv(candidate)
        return str(candidate)

    found = find_dotenv(usecwd=True)
    if found:
        load_dotenv(found)
        return found

    return None

loaded_from = _load_env()

def get_next_example_from_db() -> tuple[int, str, str, str]:
    """
    This function retrieves next question (make sure every question only 2 annotators use predefined function)

    Returns:
         (question_id, question_text, answer_text, passage_text)
    """
    question_id = 1
    question_text = 'Example question from the database'
    answer_text = 'Example answer generated by the model'
    passage_text = ( 'This is an example passage.\n\n'
                     'Later this text will come from Postgres.')
    return question_id, question_text, answer_text, passage_text

def save_annotation_to_db(question_id: int, flu: int, comp: int, fact: int,
                          rej_q: bool, alt_q: str | None, rej_a: bool, alt_a: str | None) -> None:
    """
    Takes Userinterface inputs which describe the answer to the question like how fluent, comprehensive and factual
    the answer is. It is called from the Flask app posting to the /submit_annotation.

    Args:
        question_id (int): Unique ID to keep track of the answered and unanswered questions.
        flu (int): Fluent parameter, describes how fluent the question is with ratings (1-5).
        comp (int): Comprehensive parameter, describes how comprehensive the question is with ratings (1-5).
        fact (int): Factual parameter, describes how factual the questions is with ratings (1-5).
        rej_q (bool): Rejected question, set to True if the question is rejected.
        alt_q (str | None): Alternative question, user input of a question example if original question is rejected.
        rej_a (bool): Rejected answer, set to True if the answer is rejected.
        alt_a (str | None): Alternative answer, user input of a answer example if original answer is rejected.
    """
    pass

def create_app() -> Flask:
    """
    Create and configure the Flask application.

    This function initializes a Flask app instance, sets up basic configuration,
    and defines routes for adding parameter Values to Database

    Routes:
        GET /                       – Render the main page showing calling a question from the DB.
        POST /submit_annotation     – Add the values of fluency, comprehensiveness and factual to the DB.

    Returns:
        Flask: The configured Flask application instance.
    """
    app = Flask(__name__, template_folder=str(cwd.parent / 'templates'))
    app.config['TEMPLATES_AUTO_RELOAD'] = True
    flask_log = get_logger(__name__)

    @app.get('/')
    def home():
        # Load one question
        flask_log.info('New Question loaded')
        question_id, question_text, answer_text, passage_text = get_next_example_from_db()
        return render_template('index.html', question_id=question_id,
                               question_text=question_text, answer_text=answer_text,
                               passage_text=passage_text)

    @app.post('/submit_annotation')
    def submit_annotation():
        # Read values fro UI
        question_id = int(request.form['question_id'])
        fluency = int(request.form['fluency'])
        comprehensive = int(request.form['comprehensiveness'])
        factual = int(request.form['factuality'])

        # Check if question is rejected!
        rejected = request.form.get('reject_question', '0') == '1'
        alternative_question = request.form.get('alternative_question', '').strip()
        if not rejected:
            alternative_question = None

        # Check if answer is rejected!
        rejected_a = request.form.get('reject_answer', '0') == '1'
        alternative_answer = request.form.get('alternative_answer', '').strip()
        if not rejected_a:
            alternative_answer = None

        # Store in DB
        flask_log.info(f'\nQuestion_id: {question_id}\nFluency: {fluency}\nComprehensiveness: {comprehensive}\nFactual: {factual}')
        flask_log.info(f'Alternative Question: {alternative_question}')
        flask_log.info(f'Alternative Answer: {alternative_answer}')
        save_annotation_to_db(question_id=question_id, flu=fluency,
                              comp=comprehensive, fact=factual,
                              rej_q=rejected, alt_q=alternative_question,
                              rej_a=rejected_a, alt_a=alternative_answer)

        # Load next question
        return redirect(url_for('home'))

    return app

def main() -> None:
    """
    Entry point for running the Flask application.

    This function creates the Flask app instance, reads the desired port
    from the environment variable `SOP_UI_PORT` (defaulting to 8000),
    and starts the development server.

    It also prints information about the loaded .env file and the chosen port
    for easier debugging and transparency during startup.

    Returns:
        None
    """
    setup_logging(app_name='user_interface', log_dir=os.getenv('GUI_LOG_DIR'))
    log = get_logger(__name__)

    app = create_app()
    port = int(os.getenv("SOP_UI_PORT", "8000"))
    log.info(f".env loaded from: {loaded_from}")
    log.info(f"SOP_UI_PORT = {port}")
    app.run(host='0.0.0.0', port=port, debug=False)


if __name__ == '__main__':
    main()